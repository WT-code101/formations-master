<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>隊形大師 (Formations Master)</title>
    
    <!-- 載入 Tailwind CSS (樣式) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 載入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- 載入 Babel (讓瀏覽器看得懂 JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* 自定義捲軸樣式 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; 
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; 
        }
        body {
            margin: 0;
            overflow: hidden;
        }
        
        /* 隱藏水平捲軸但保留捲動功能 */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- 內建圖示元件 ---
        const Icon = ({ children, size = 24, ...props }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                {...props}
            >
                {children}
            </svg>
        );

        const lucideReact = {
            Play: (props) => <Icon {...props}><polygon points="5 3 19 12 5 21 5 3"></polygon></Icon>,
            Pause: (props) => <Icon {...props}><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></Icon>,
            Plus: (props) => <Icon {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></Icon>,
            Trash2: (props) => <Icon {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></Icon>,
            Users: (props) => <Icon {...props}><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></Icon>,
            Settings: (props) => <Icon {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></Icon>,
            Menu: (props) => <Icon {...props}><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></Icon>,
            X: (props) => <Icon {...props}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></Icon>,
            Edit: (props) => <Icon {...props}><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></Icon>,
            RefreshCw: (props) => <Icon {...props}><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></Icon>,
            Grid: (props) => <Icon {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></Icon>,
            Magnet: (props) => <Icon {...props}><path d="m6 15-4-4 6.75-6.77a7.79 7.79 0 0 1 10.5 10.5L12.5 21l-4-4"></path><path d="m9 9 5 5"></path></Icon>,
            ZoomIn: (props) => <Icon {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></Icon>,
            ZoomOut: (props) => <Icon {...props}><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></Icon>,
            Maximize: (props) => <Icon {...props}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></Icon>
        };

        const { Play, Pause, Plus, Trash2, Users, Settings, Menu, X, Edit, RefreshCw, Grid, Magnet, ZoomIn, ZoomOut, Maximize } = lucideReact;

        // 預設顏色庫
        const COLORS = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#96CEB4', 
            '#FFEEAD', '#D4A5A5', '#9B59B6', '#3498DB', '#E67E22'
        ];

        // 核心設定：格線大小與舞者大小 (邏輯單位) - 現在可調整
        const DEFAULT_GRID_SIZE = 40; 
        const DEFAULT_PERFORMER_SIZE = 30; 

        // 預設資料
        const DEFAULT_PERFORMERS = [
            { id: 'p1', name: '1', color: COLORS[0], shape: 'circle' },
            { id: 'p2', name: '2', color: COLORS[1], shape: 'square' },
            { id: 'p3', name: '3', color: COLORS[2], shape: 'triangle' },
            { id: 'p4', name: '4', color: COLORS[3], shape: 'circle' },
        ];
        const DEFAULT_FRAMES = [
            {
                id: 'f1',
                name: '開場',
                duration: 2000,
                positions: {
                    'p1': { x: 320, y: 320 }, 
                    'p2': { x: 400, y: 320 }, 
                    'p3': { x: 480, y: 320 }, 
                    'p4': { x: 400, y: 400 }, 
                }
            }
        ];
        const DEFAULT_STAGE_SIZE = { width: 800, height: 600 };
        const STORAGE_KEY = 'formation-master-save-v3';
        
        // 支援的形狀
        const SHAPES = {
            circle: { label: '圓形', render: (color) => <circle cx="12" cy="12" r="11" fill={color} /> },
            square: { label: '正方形', render: (color) => <rect x="2" y="2" width="20" height="20" rx="4" fill={color} /> },
            triangle: { label: '三角形', render: (color) => <polygon points="12,1 23,22 1,22" fill={color} /> },
            diamond: { label: '菱形', render: (color) => <polygon points="12,1 23,12 12,23 1,12" fill={color} /> },
            arrow: { label: '箭頭', render: (color) => <path d="M12 23L2 13h6V1h8v12h6z" fill={color} /> },
            star: { label: '星形', render: (color) => <polygon points="12,2 15,9 22,9 17,14 19,21 12,17 5,21 7,14 2,9 9,9" fill={color} /> }
        };

        // 渲染舞者形狀的元件
        const PerformerShape = ({ shape, color, className, style, size = 24 }) => {
            const shapeConfig = SHAPES[shape] || SHAPES.circle;
            return (
                <div 
                    className={className}
                    style={{
                        width: '100%',
                        height: '100%',
                        ...style
                    }}
                >
                    <svg 
                        width="100%" 
                        height="100%" 
                        viewBox="0 0 24 24" 
                        fill="none" 
                        xmlns="http://www.w3.org/2000/svg"
                        style={{ display: 'block' }}
                    >
                        {shapeConfig.render(color)}
                    </svg>
                </div>
            );
        };

        function App() {
            // --- State ---
            const [performers, setPerformers] = useState(DEFAULT_PERFORMERS);
            const [frames, setFrames] = useState(DEFAULT_FRAMES);
            const [stageSize, setStageSize] = useState(DEFAULT_STAGE_SIZE);
            
            // 縮放和大小控制
            const [zoomLevel, setZoomLevel] = useState(1);
            const [gridSize, setGridSize] = useState(DEFAULT_GRID_SIZE);
            const [performerSize, setPerformerSize] = useState(DEFAULT_PERFORMER_SIZE);

            const [showSettings, setShowSettings] = useState(false); 
            const [editingPerformer, setEditingPerformer] = useState(null); 
            
            const [currentFrameIndex, setCurrentFrameIndex] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [isSidebarOpen, setIsSidebarOpen] = useState(true);
            const [lastSaved, setLastSaved] = useState(null); 
            const [showGrid, setShowGrid] = useState(true); 
            const [snapToGrid, setSnapToGrid] = useState(true); 
            
            const [playbackTime, setPlaybackTime] = useState(0); 
            const requestRef = useRef();
            const startTimeRef = useRef();
            const totalDurationRef = useRef(0);

            const [draggingId, setDraggingId] = useState(null);
            const stageRef = useRef(null);
            const timelineRef = useRef(null); 

            // --- Effects (Auto-Save Logic with Debounce) ---
            useEffect(() => {
                const savedData = localStorage.getItem(STORAGE_KEY);
                if (savedData) {
                    try {
                        const parsed = JSON.parse(savedData);
                        if (parsed.performers) setPerformers(parsed.performers);
                        if (parsed.frames) setFrames(parsed.frames);
                        if (parsed.stageSize) setStageSize(parsed.stageSize);
                        if (parsed.gridSize) setGridSize(parsed.gridSize);
                        if (parsed.performerSize) setPerformerSize(parsed.performerSize);
                        if (parsed.zoomLevel) setZoomLevel(parsed.zoomLevel);
                        if (parsed.showGrid !== undefined) setShowGrid(parsed.showGrid);
                        if (parsed.snapToGrid !== undefined) setSnapToGrid(parsed.snapToGrid);
                        console.log("已載入儲存進度");
                    } catch (e) {
                        console.error("讀取儲存檔案失敗", e);
                    }
                }
            }, []);

            useEffect(() => {
                const timer = setTimeout(() => {
                    const dataToSave = {
                        performers,
                        frames,
                        stageSize,
                        gridSize,
                        performerSize,
                        zoomLevel,
                        showGrid,
                        snapToGrid
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
                    setLastSaved(new Date());
                }, 500);
                return () => clearTimeout(timer);
            }, [performers, frames, stageSize, gridSize, performerSize, zoomLevel, showGrid, snapToGrid]);

            useEffect(() => {
                const handleResize = () => {
                    if (window.innerWidth < 768) {
                        setIsSidebarOpen(false);
                    } else {
                        setIsSidebarOpen(true);
                    }
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            useEffect(() => {
                return () => {
                    if (requestRef.current) {
                        cancelAnimationFrame(requestRef.current);
                    }
                };
            }, []);

            useEffect(() => {
                setFrames(prevFrames => {
                    const newFrames = prevFrames.map(frame => {
                        const newPositions = { ...frame.positions };
                        let changed = false;
                        
                        const occupied = new Set();
                        Object.values(newPositions).forEach(pos => {
                            const gx = Math.round(pos.x / gridSize);
                            const gy = Math.round(pos.y / gridSize);
                            occupied.add(`${gx},${gy}`);
                        });

                        const findFreeSpot = () => {
                            const centerGx = Math.round((stageSize.width / 2) / gridSize);
                            const centerGy = Math.round((stageSize.height / 2) / gridSize);
                            
                            let radius = 0;
                            while (radius < 50) { 
                                for (let x = -radius; x <= radius; x++) {
                                    for (let y = -radius; y <= radius; y++) {
                                        if (Math.abs(x) !== radius && Math.abs(y) !== radius) continue;
                                        const targetGx = centerGx + x;
                                        const targetGy = centerGy + y;
                                        if (!occupied.has(`${targetGx},${targetGy}`)) {
                                            return { x: targetGx * gridSize, y: targetGy * gridSize };
                                        }
                                    }
                                }
                                radius++;
                            }
                            return { x: centerGx * gridSize, y: centerGy * gridSize };
                        };

                        performers.forEach((p) => {
                            if (!newPositions[p.id]) {
                                const spot = findFreeSpot();
                                newPositions[p.id] = spot;
                                const gx = Math.round(spot.x / gridSize);
                                const gy = Math.round(spot.y / gridSize);
                                occupied.add(`${gx},${gy}`);
                                changed = true;
                            }
                        });
                        return changed ? { ...frame, positions: newPositions } : frame;
                    });
                    
                    if (JSON.stringify(newFrames) !== JSON.stringify(prevFrames)) {
                        return newFrames;
                    }
                    return prevFrames;
                });
            }, [performers, stageSize, gridSize]);

            const getDisplayFrameIndex = () => {
                if (!isPlaying) return currentFrameIndex;
                let accumulatedTime = 0;
                for (let i = 0; i < frames.length - 1; i++) {
                    if (playbackTime < accumulatedTime + frames[i].duration) {
                        return i;
                    }
                    accumulatedTime += frames[i].duration;
                }
                return frames.length - 1;
            };

            const displayFrameIndex = getDisplayFrameIndex();

            useEffect(() => {
                if (timelineRef.current && isPlaying) {
                    const frameElements = timelineRef.current.children;
                    if (frameElements[displayFrameIndex]) {
                        try {
                            frameElements[displayFrameIndex].scrollIntoView({ 
                                behavior: 'smooth', 
                                block: 'nearest', 
                                inline: 'center' 
                            });
                        } catch (e) {
                            console.warn('ScrollIntoView failed:', e);
                        }
                    }
                }
            }, [displayFrameIndex, isPlaying]);

            // --- Actions ---
            const resetProject = () => {
                if (confirm('確定要重置所有資料嗎？這將會清除目前的進度並重新開始。')) {
                    localStorage.removeItem(STORAGE_KEY);
                    setPerformers(DEFAULT_PERFORMERS);
                    setFrames(DEFAULT_FRAMES);
                    setStageSize(DEFAULT_STAGE_SIZE);
                    setGridSize(DEFAULT_GRID_SIZE);
                    setPerformerSize(DEFAULT_PERFORMER_SIZE);
                    setZoomLevel(1);
                    setShowGrid(true);
                    setSnapToGrid(true);
                    setCurrentFrameIndex(0);
                    setIsPlaying(false);
                    setPlaybackTime(0);
                }
            };

            const toggleSnapToGrid = () => {
                const newSnapState = !snapToGrid;
                setSnapToGrid(newSnapState);
                if (newSnapState) {
                    // 立即將所有舞者對齊到格線
                    const newFrames = [...frames];
                    const currentPositions = newFrames[currentFrameIndex].positions;
                    const newPositions = {};
                    let changed = false;
                    Object.keys(currentPositions).forEach(key => {
                        const pos = currentPositions[key];
                        const snappedX = Math.round(pos.x / gridSize) * gridSize;
                        const snappedY = Math.round(pos.y / gridSize) * gridSize;
                        if (snappedX !== pos.x || snappedY !== pos.y) {
                            newPositions[key] = { x: snappedX, y: snappedY };
                            changed = true;
                        } else {
                            newPositions[key] = pos;
                        }
                    });
                    if (changed) {
                        newFrames[currentFrameIndex].positions = newPositions;
                        setFrames(newFrames);
                    }
                }
            };

            const handleZoomIn = () => {
                setZoomLevel(prev => Math.min(prev + 0.05, 3));
            };

            const handleZoomOut = () => {
                setZoomLevel(prev => Math.max(prev - 0.05, 0.1));
            };

            const handleResetZoom = () => {
                setZoomLevel(1);
            };

            const addPerformer = () => {
                const id = `p${Date.now()}`;
                const num = performers.length + 1;
                const color = COLORS[performers.length % COLORS.length];
                setPerformers([...performers, { id, name: `${num}`, color, shape: 'circle' }]);
            };

            const removePerformer = (id, e) => {
                if (e && e.stopPropagation) e.stopPropagation();
                
                if (window.confirm('確定要刪除這位舞者嗎？')) {
                    if (editingPerformer === id) {
                        setEditingPerformer(null);
                    }
                    setPerformers(prev => prev.filter(p => p.id !== id));
                    setFrames(prevFrames => prevFrames.map(frame => {
                        const newPositions = { ...frame.positions };
                        delete newPositions[id];
                        return { ...frame, positions: newPositions };
                    }));
                }
            };

            const updatePerformer = (id, newProps) => {
                setPerformers(performers.map(p => p.id === id ? { ...p, ...newProps } : p));
            };

            const addFrame = () => {
                const lastFrame = frames[frames.length - 1];
                const newFrame = {
                    id: `f${Date.now()}`,
                    name: `隊形 ${frames.length + 1}`,
                    duration: 2000,
                    positions: JSON.parse(JSON.stringify(lastFrame.positions))
                };
                setFrames([...frames, newFrame]);
                setCurrentFrameIndex(frames.length);
            };

            const deleteFrame = (index) => {
                if (frames.length <= 1) return alert("至少需要保留一個隊形畫面");
                const newFrames = frames.filter((_, i) => i !== index);
                setFrames(newFrames);
                if (currentFrameIndex >= newFrames.length) {
                    setCurrentFrameIndex(newFrames.length - 1);
                }
            };

            const updatePosition = (id, x, y) => {
                const newFrames = [...frames];
                const currentPos = newFrames[currentFrameIndex].positions[id];
                newFrames[currentFrameIndex].positions = {
                    ...newFrames[currentFrameIndex].positions,
                    [id]: { ...currentPos, x, y }
                };
                setFrames(newFrames);
            };

            const calculatePosition = (clientX, clientY) => {
                const stage = stageRef.current;
                if (!stage) return { x: 0, y: 0 };
                
                const rect = stage.getBoundingClientRect();
                const scaleX = (stageSize.width * zoomLevel) / stage.clientWidth;
                const scaleY = (stageSize.height * zoomLevel) / stage.clientHeight;

                let x = (clientX - rect.left - stage.clientLeft) * scaleX;
                let y = (clientY - rect.top - stage.clientTop) * scaleY;

                x = Math.max(0, Math.min(stageSize.width, x));
                y = Math.max(0, Math.min(stageSize.height, y));
                
                return { x, y };
            };

            // --- Event Handlers ---
            const handleMouseDown = (e, id) => {
                if (isPlaying) return;
                setDraggingId(id);
                e.stopPropagation();
            };

            const handleMouseMove = (e) => {
                if (!draggingId || isPlaying) return;
                e.preventDefault();
                let { x, y } = calculatePosition(e.clientX, e.clientY);
                if (snapToGrid) {
                    x = Math.round(x / gridSize) * gridSize;
                    y = Math.round(y / gridSize) * gridSize;
                }
                updatePosition(draggingId, x, y);
            };

            const handleMouseUp = () => {
                setDraggingId(null);
            };

            const handleTouchStart = (e, id) => {
                if (isPlaying) return;
                setDraggingId(id);
                e.stopPropagation();
            };

            const handleTouchMove = (e) => {
                if (!draggingId || isPlaying) return;
                e.preventDefault();
                const touch = e.touches[0];
                if (!touch) return;
                
                let { x, y } = calculatePosition(touch.clientX, touch.clientY);
                if (snapToGrid) {
                    x = Math.round(x / gridSize) * gridSize;
                    y = Math.round(y / gridSize) * gridSize;
                }
                updatePosition(draggingId, x, y);
            };

            const handleTouchEnd = () => {
                setDraggingId(null);
            };

            // --- Playback Logic ---
            const startPlayback = () => {
                if (frames.length < 2) return;
                setIsPlaying(true);
                setPlaybackTime(0);
                totalDurationRef.current = frames.reduce((acc, f, i) => {
                    if (i === frames.length - 1) return acc; 
                    return acc + f.duration;
                }, 0);
                startTimeRef.current = performance.now();
                requestRef.current = requestAnimationFrame(animate);
            };

            const stopPlayback = () => {
                setIsPlaying(false);
                setPlaybackTime(0);
                if (requestRef.current) cancelAnimationFrame(requestRef.current);
                setCurrentFrameIndex(0); 
            };

            const animate = (time) => {
                const elapsed = time - startTimeRef.current;
                
                if (elapsed >= totalDurationRef.current) {
                    setIsPlaying(false);
                    setPlaybackTime(0);
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                    setCurrentFrameIndex(frames.length - 1); 
                    return;
                }

                setPlaybackTime(elapsed);
                requestRef.current = requestAnimationFrame(animate);
            };

            const getInterpolatedPositions = () => {
                if (!isPlaying) return frames[currentFrameIndex].positions;
                if (frames.length < 2) return frames[0].positions;

                let accumulatedTime = 0;
                let activeIndex = 0;

                for (let i = 0; i < frames.length - 1; i++) {
                    if (playbackTime < accumulatedTime + frames[i].duration) {
                        activeIndex = i;
                        break;
                    }
                    accumulatedTime += frames[i].duration;
                }
                
                if (activeIndex >= frames.length - 1) {
                    activeIndex = Math.max(0, frames.length - 2);
                }

                const startFrame = frames[activeIndex];
                const endFrame = frames[activeIndex + 1];
                
                const segmentTime = playbackTime - accumulatedTime;
                const progress = Math.min(1, Math.max(0, segmentTime / startFrame.duration));
                const ease = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                const t = ease(progress);

                const interpolated = {};
                performers.forEach(p => {
                    const startPos = startFrame.positions[p.id] || { x: 0, y: 0 };
                    const endPos = endFrame.positions[p.id] || startPos;

                    interpolated[p.id] = {
                        x: startPos.x + (endPos.x - startPos.x) * t,
                        y: startPos.y + (endPos.y - startPos.y) * t
                    };
                });

                return interpolated;
            };

            const displayPositions = getInterpolatedPositions();
            const activePerformer = performers.find(p => p.id === editingPerformer);
            const gridPctX = stageSize.width > 0 ? (gridSize / stageSize.width) * 100 : 0;
            const gridPctY = stageSize.height > 0 ? (gridSize / stageSize.height) * 100 : 0;

            // --- Render ---
            return (
                <div 
                    className="flex flex-col h-screen bg-gray-900 text-white font-sans overflow-hidden"
                    onMouseUp={handleMouseUp}
                    onMouseMove={handleMouseMove}
                    onTouchMove={handleTouchMove}
                    onTouchEnd={handleTouchEnd}
                >
                    {/* Header */}
                    <div className="h-14 bg-gray-800 border-b border-gray-700 flex items-center justify-between px-4 shrink-0 z-30 relative">
                        <div className="flex items-center gap-2 shrink min-w-0 mr-2">
                            <button 
                                onClick={() => setIsSidebarOpen(!isSidebarOpen)}
                                className="md:hidden p-1 text-gray-400 hover:text-white shrink-0"
                            >
                                {isSidebarOpen ? <X size={24} /> : <Menu size={24} />}
                            </button>
                            <div className="bg-purple-600 p-1.5 rounded-lg shrink-0">
                                <Users size={20} />
                            </div>
                            <div className="flex flex-col justify-center min-w-0">
                                <h1 className="text-lg font-bold tracking-wide truncate leading-tight">Formations <span className="hidden sm:inline">Master</span></h1>
                                {lastSaved && (
                                    <span className="text-[10px] text-green-400 flex items-center gap-1 opacity-80 truncate">
                                        已自動儲存
                                    </span>
                                )}
                            </div>
                        </div>
                        
                        <div className="flex items-center gap-1 sm:gap-2 overflow-x-auto no-scrollbar pl-2 justify-end shrink-0 max-w-[65%] sm:max-w-none">
                            {!isPlaying ? (
                                <button 
                                    onClick={startPlayback}
                                    className="flex items-center gap-2 px-3 sm:px-4 py-1.5 bg-green-600 hover:bg-green-500 rounded-full transition-colors font-medium text-xs sm:text-sm whitespace-nowrap shrink-0"
                                >
                                    <Play size={16} fill="currentColor" /> <span className="hidden sm:inline">播放</span>
                                </button>
                            ) : (
                                <button 
                                    onClick={stopPlayback}
                                    className="flex items-center gap-2 px-3 sm:px-4 py-1.5 bg-red-600 hover:bg-red-500 rounded-full transition-colors font-medium text-xs sm:text-sm whitespace-nowrap shrink-0"
                                >
                                    <Pause size={16} fill="currentColor" /> 停止
                                </button>
                            )}

                            <button 
                                onClick={resetProject}
                                className="p-2 hover:bg-gray-700 rounded-full text-gray-400 hover:text-red-400 transition shrink-0"
                                title="重置專案"
                            >
                                <RefreshCw size={20} />
                            </button>

                            <button 
                                onClick={() => setShowSettings(true)}
                                className="p-2 hover:bg-gray-700 rounded-full text-gray-400 hover:text-white transition shrink-0"
                                title="設定"
                            >
                                <Settings size={20} />
                            </button>
                        </div>
                    </div>

                    {/* 統一設定視窗 */}
                    {showSettings && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm" onClick={() => setShowSettings(false)}>
                            <div className="bg-gray-800 border border-gray-700 p-6 rounded-xl w-96 max-h-[85vh] overflow-y-auto shadow-2xl" onClick={e => e.stopPropagation()}>
                                <h3 className="text-xl font-bold mb-6 flex items-center gap-2 text-white"><Settings size={20} /> 設定</h3>
                                
                                <div className="space-y-6">
                                    {/* 場地設定 */}
                                    <div className="bg-gray-750 p-4 rounded-lg">
                                        <h4 className="text-sm font-bold text-gray-300 mb-3">場地尺寸</h4>
                                        <div className="space-y-3">
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">場地寬度</label>
                                                <input 
                                                    type="number" 
                                                    value={stageSize.width}
                                                    onChange={(e) => setStageSize({...stageSize, width: Math.max(100, Number(e.target.value))})}
                                                    className="w-full bg-gray-900 border border-gray-600 rounded px-3 py-2 text-white focus:border-purple-500 outline-none transition"
                                                    min="100"
                                                />
                                            </div>
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-1">場地深度</label>
                                                <input 
                                                    type="number" 
                                                    value={stageSize.height}
                                                    onChange={(e) => setStageSize({...stageSize, height: Math.max(100, Number(e.target.value))})}
                                                    className="w-full bg-gray-900 border border-gray-600 rounded px-3 py-2 text-white focus:border-purple-500 outline-none transition"
                                                    min="100"
                                                />
                                            </div>
                                        </div>
                                    </div>

                                    {/* 縮放設定 */}
                                    <div className="bg-gray-750 p-4 rounded-lg">
                                        <h4 className="text-sm font-bold text-gray-300 mb-3 flex items-center gap-2">
                                            <Maximize size={16} /> 舞台縮放
                                        </h4>
                                        <div>
                                            <label className="block text-sm text-gray-400 mb-2">縮放比例：{(zoomLevel * 100).toFixed(0)}%</label>
                                            <div className="flex items-center gap-3">
                                                <button 
                                                    onClick={handleZoomOut}
                                                    className="p-2 bg-gray-700 hover:bg-gray-600 rounded transition"
                                                    title="縮小"
                                                >
                                                    <ZoomOut size={18} />
                                                </button>
                                                <input 
                                                    type="range" 
                                                    min="0.1" 
                                                    max="3" 
                                                    step="0.05"
                                                    value={zoomLevel}
                                                    onChange={(e) => setZoomLevel(Number(e.target.value))}
                                                    className="flex-1"
                                                />
                                                <button 
                                                    onClick={handleZoomIn}
                                                    className="p-2 bg-gray-700 hover:bg-gray-600 rounded transition"
                                                    title="放大"
                                                >
                                                    <ZoomIn size={18} />
                                                </button>
                                            </div>
                                            <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                <span>10%</span>
                                                <button 
                                                    onClick={handleResetZoom}
                                                    className="text-blue-400 hover:text-blue-300"
                                                >
                                                    重置 100%
                                                </button>
                                                <span>300%</span>
                                            </div>
                                        </div>
                                    </div>

                                    {/* 舞者與格線設定 */}
                                    <div className="bg-gray-750 p-4 rounded-lg">
                                        <h4 className="text-sm font-bold text-gray-300 mb-3">舞者與格線</h4>
                                        <div className="space-y-4">
                                            {/* 舞者大小 */}
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-2">舞者大小：{performerSize}px</label>
                                                <input 
                                                    type="range" 
                                                    min="15" 
                                                    max="60" 
                                                    step="5"
                                                    value={performerSize}
                                                    onChange={(e) => setPerformerSize(Number(e.target.value))}
                                                    className="w-full"
                                                />
                                                <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                    <span>小</span>
                                                    <span>大</span>
                                                </div>
                                            </div>

                                            {/* 格線間距 */}
                                            <div>
                                                <label className="block text-sm text-gray-400 mb-2">格線間距：{gridSize}px</label>
                                                <input 
                                                    type="range" 
                                                    min="20" 
                                                    max="80" 
                                                    step="10"
                                                    value={gridSize}
                                                    onChange={(e) => setGridSize(Number(e.target.value))}
                                                    className="w-full"
                                                />
                                                <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                    <span>密</span>
                                                    <span>疏</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    {/* 顯示選項 */}
                                    <div className="bg-gray-750 p-4 rounded-lg">
                                        <h4 className="text-sm font-bold text-gray-300 mb-3">顯示選項</h4>
                                        <div className="space-y-3">
                                            {/* 顯示格線 */}
                                            <div className="flex items-center justify-between">
                                                <div className="flex items-center gap-2">
                                                    <Grid size={18} className="text-gray-400" />
                                                    <span className="text-sm text-gray-300">顯示格線</span>
                                                </div>
                                                <button 
                                                    onClick={() => setShowGrid(!showGrid)}
                                                    className={`relative w-12 h-6 rounded-full transition ${showGrid ? 'bg-green-600' : 'bg-gray-600'}`}
                                                >
                                                    <div className={`absolute top-1 left-1 w-4 h-4 bg-white rounded-full transition-transform ${showGrid ? 'translate-x-6' : ''}`}></div>
                                                </button>
                                            </div>

                                            {/* 吸附格線 */}
                                            <div className="flex items-center justify-between">
                                                <div className="flex items-center gap-2">
                                                    <Magnet size={18} className="text-gray-400" />
                                                    <span className="text-sm text-gray-300">吸附格線</span>
                                                </div>
                                                <button 
                                                    onClick={toggleSnapToGrid}
                                                    className={`relative w-12 h-6 rounded-full transition ${snapToGrid ? 'bg-green-600' : 'bg-gray-600'}`}
                                                >
                                                    <div className={`absolute top-1 left-1 w-4 h-4 bg-white rounded-full transition-transform ${snapToGrid ? 'translate-x-6' : ''}`}></div>
                                                </button>
                                            </div>
                                        </div>
                                    </div>

                                    {/* 恢復預設值 */}
                                    <div className="pt-3 border-t border-gray-700">
                                        <button 
                                            onClick={() => {
                                                setZoomLevel(1);
                                                setPerformerSize(DEFAULT_PERFORMER_SIZE);
                                                setGridSize(DEFAULT_GRID_SIZE);
                                                setStageSize(DEFAULT_STAGE_SIZE);
                                                setShowGrid(true);
                                                setSnapToGrid(true);
                                            }}
                                            className="w-full py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm transition"
                                        >
                                            恢復所有預設值
                                        </button>
                                    </div>

                                    <button 
                                        onClick={() => setShowSettings(false)}
                                        className="w-full py-2 bg-purple-600 hover:bg-purple-500 rounded font-medium text-white transition"
                                    >
                                        完成
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Performer Settings Modal */}
                    {activePerformer && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm" onClick={() => setEditingPerformer(null)}>
                            <div className="bg-gray-800 border border-gray-700 p-6 rounded-xl w-80 shadow-2xl max-h-[80vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                                <div className="flex justify-between items-center mb-4">
                                    <h3 className="text-xl font-bold text-white flex items-center gap-2">
                                        <PerformerShape shape={activePerformer.shape} color={activePerformer.color} size={24} />
                                        舞者設定
                                    </h3>
                                    <button onClick={() => setEditingPerformer(null)} className="text-gray-400 hover:text-white"><X size={20} /></button>
                                </div>
                                
                                <div className="space-y-5">
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-1">名稱 / 代號</label>
                                        <input 
                                            value={activePerformer.name}
                                            onChange={(e) => updatePerformer(activePerformer.id, { name: e.target.value })}
                                            className="w-full bg-gray-900 border border-gray-600 rounded px-3 py-2 text-white focus:border-purple-500 outline-none"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-2">代表顏色</label>
                                        <div className="flex flex-wrap gap-2">
                                            {COLORS.map(c => (
                                                <button 
                                                    key={c}
                                                    onClick={() => updatePerformer(activePerformer.id, { color: c })}
                                                    className={`w-8 h-8 rounded-full border-2 transition ${activePerformer.color === c ? 'border-white scale-110' : 'border-transparent hover:scale-105'}`}
                                                    style={{ backgroundColor: c }}
                                                />
                                            ))}
                                            <div className="relative w-8 h-8 rounded-full border-2 border-gray-600 overflow-hidden">
                                                <input 
                                                    type="color" 
                                                    value={activePerformer.color}
                                                    onChange={(e) => updatePerformer(activePerformer.id, { color: e.target.value })}
                                                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                                />
                                                <div className="w-full h-full flex items-center justify-center bg-gray-700 text-xs text-gray-300">+</div>
                                            </div>
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-sm text-gray-400 mb-2">形狀</label>
                                        <div className="grid grid-cols-3 gap-2">
                                            {Object.entries(SHAPES).map(([key, config]) => (
                                                <button
                                                    key={key}
                                                    onClick={() => updatePerformer(activePerformer.id, { shape: key })}
                                                    className={`flex flex-col items-center justify-center p-2 rounded border transition ${activePerformer.shape === key ? 'bg-purple-900/50 border-purple-500' : 'bg-gray-900 border-gray-700 hover:bg-gray-800'}`}
                                                >
                                                    <PerformerShape shape={key} color={activePerformer.color} size={24} className="mb-1" />
                                                    <span className="text-[10px] text-gray-400">{config.label}</span>
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    <div className="pt-2 border-t border-gray-700 flex justify-between">
                                        <button 
                                            onClick={(e) => removePerformer(activePerformer.id, e)}
                                            className="px-4 py-2 text-red-400 hover:text-red-300 text-sm hover:bg-red-900/20 rounded transition"
                                        >
                                            刪除舞者
                                        </button>
                                        <button 
                                            onClick={() => setEditingPerformer(null)}
                                            className="px-6 py-2 bg-purple-600 hover:bg-purple-500 rounded font-medium text-white text-sm transition"
                                        >
                                            完成
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="flex flex-1 overflow-hidden relative">
                        {/* Sidebar */}
                        <div 
                            className={`
                                absolute md:relative inset-y-0 left-0 z-20 
                                w-64 bg-gray-800 border-r border-gray-700 flex flex-col shrink-0
                                transform transition-transform duration-300 ease-in-out shadow-xl md:shadow-none
                                ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full md:translate-x-0 md:w-0 md:border-none md:overflow-hidden'}
                            `}
                        >
                            <button onClick={() => setIsSidebarOpen(false)} className="absolute right-2 top-2 p-1 text-gray-400 hover:text-white md:hidden"><X size={20} /></button>

                            <div className="p-4 border-b border-gray-700 flex justify-between items-center mt-2 md:mt-0">
                                <h2 className="font-semibold text-gray-300">舞者名單</h2>
                                <button onClick={addPerformer} className="p-1 hover:bg-gray-700 rounded text-green-400 transition" title="新增舞者"><Plus size={20} /></button>
                            </div>
                            <div className="flex-1 overflow-y-auto p-2 space-y-2">
                                {performers.map(p => (
                                    <div key={p.id} className="flex items-center gap-3 p-2 bg-gray-750 hover:bg-gray-700 rounded-lg group transition">
                                        <button 
                                            onClick={() => setEditingPerformer(p.id)}
                                            className="relative w-8 h-8 flex items-center justify-center shrink-0 hover:scale-110 transition"
                                            title="點擊設定"
                                        >
                                            <PerformerShape shape={p.shape} color={p.color} size={32} />
                                            <div className="absolute -bottom-1 -right-1 bg-gray-800 rounded-full p-0.5 border border-gray-600">
                                                <Edit size={8} className="text-white" />
                                            </div>
                                        </button>
                                        
                                        <input 
                                            value={p.name}
                                            onChange={(e) => updatePerformer(p.id, { name: e.target.value })}
                                            className="bg-transparent border-none text-sm text-gray-200 focus:outline-none w-full"
                                        />
                                        
                                        <button 
                                            onClick={(e) => removePerformer(p.id, e)}
                                            className="opacity-100 sm:opacity-0 group-hover:opacity-100 text-gray-500 hover:text-red-400 transition"
                                        >
                                            <Trash2 size={16} />
                                        </button>
                                    </div>
                                ))}
                            </div>
                            <div className="p-4 border-t border-gray-700 text-xs text-gray-500 text-center">
                                共 {performers.length} 位舞者
                            </div>
                        </div>
                        
                        {isSidebarOpen && (
                            <div className="absolute inset-0 bg-black/50 z-10 md:hidden" onClick={() => setIsSidebarOpen(false)} />
                        )}

                        {/* Main Stage Area */}
                        <div className="flex-1 bg-gray-900 relative overflow-hidden flex flex-col">
                            <div className="absolute top-4 left-4 z-10 bg-gray-800/80 backdrop-blur-sm px-3 py-1.5 rounded-lg text-xs sm:text-sm text-gray-300 border border-gray-700 pointer-events-none">
                                {isPlaying ? `播放中... ${(playbackTime / 1000).toFixed(1)}s` : `編輯: ${frames[currentFrameIndex].name}`}
                            </div>

                            {zoomLevel !== 1 && (
                                <div className="absolute top-4 right-4 z-10 bg-blue-600/80 backdrop-blur-sm px-3 py-1.5 rounded-lg text-xs text-white border border-blue-500 pointer-events-none">
                                    縮放: {(zoomLevel * 100).toFixed(0)}%
                                </div>
                            )}

                            <div 
                                className="flex-1 flex items-center justify-center p-2 sm:p-4 md:p-8 bg-gray-900 overflow-auto" 
                            >
                                {/* The Stage Container */}
                                <div 
                                    ref={stageRef}
                                    className="relative bg-gray-850 shadow-2xl border border-gray-700 rounded-sm overflow-hidden select-none"
                                    style={{
                                        width: stageSize.width * zoomLevel,
                                        height: stageSize.height * zoomLevel,
                                        minWidth: stageSize.width * zoomLevel,
                                        minHeight: stageSize.height * zoomLevel,
                                        backgroundImage: showGrid ? `linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px)` : 'none',
                                        backgroundSize: `${gridPctX * zoomLevel}% ${gridPctY * zoomLevel}%`,
                                        touchAction: 'none'
                                    }}
                                >
                                    
                                    <div className="absolute bottom-2 left-0 right-0 text-center text-gray-600 text-xs sm:text-sm font-bold opacity-50 pointer-events-none">
                                        舞台前方 (AUDIENCE)
                                    </div>

                                    {/* Performers */}
                                    {performers.map(p => {
                                        const pos = displayPositions[p.id] || { x: 0, y: 0 };
                                        const leftPct = (pos.x / stageSize.width) * 100;
                                        const topPct = (pos.y / stageSize.height) * 100;
                                        
                                        const sizePctW = (performerSize / stageSize.width) * 100;
                                        const sizePctH = (performerSize / stageSize.height) * 100;

                                        return (
                                            <div
                                                key={p.id}
                                                onMouseDown={(e) => handleMouseDown(e, p.id)}
                                                onTouchStart={(e) => handleTouchStart(e, p.id)}
                                                className={`absolute flex items-center justify-center text-gray-900 font-bold text-[10px] sm:text-xs shadow-sm ${draggingId === p.id ? 'scale-125 z-50 drop-shadow-lg' : 'hover:scale-110 z-10 cursor-grab active:cursor-grabbing'}`}
                                                style={{
                                                    left: `${leftPct}%`,
                                                    top: `${topPct}%`,
                                                    width: `${sizePctW}%`,
                                                    height: `${sizePctH}%`,
                                                    transform: 'translate(-50%, -50%)',
                                                    transition: (isPlaying || draggingId === p.id) ? 'none' : 'transform 0.1s ease-out'
                                                }}
                                            >
                                                <PerformerShape 
                                                    shape={p.shape} 
                                                    color={p.color} 
                                                    size="100%" 
                                                    className={`w-full h-full filter drop-shadow-md`}
                                                />
                                                
                                                <span className="absolute inset-0 flex items-center justify-center pointer-events-none select-none text-gray-900/80 font-bold" style={{ fontSize: `${Math.max(8, performerSize / 4)}px` }}>
                                                    {p.name}
                                                </span>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>

                            {/* Bottom Timeline */}
                            <div className="h-32 sm:h-40 bg-gray-800 border-t border-gray-700 flex flex-col shrink-0 z-30 relative">
                                <div className="flex justify-between items-center px-4 py-2 border-b border-gray-700 bg-gray-800">
                                    <span className="text-xs sm:text-sm font-semibold text-gray-400">隊形時間軸 ({frames.length})</span>
                                    <div className="flex gap-2">
                                        <button onClick={addFrame} disabled={isPlaying} className="flex items-center gap-1 px-3 py-1 bg-blue-600 hover:bg-blue-500 disabled:opacity-50 disabled:cursor-not-allowed rounded text-xs font-medium transition">
                                            <Plus size={14} /> <span className="hidden sm:inline">複製</span>
                                        </button>
                                    </div>
                                </div>

                                <div className="flex-1 overflow-x-auto p-2 sm:p-4 flex gap-3 sm:gap-4 items-center" ref={timelineRef}>
                                    {frames.map((frame, index) => (
                                        <div 
                                            key={frame.id}
                                            onClick={() => !isPlaying && setCurrentFrameIndex(index)}
                                            className={`relative flex-shrink-0 w-24 h-20 sm:w-32 sm:h-24 rounded-lg border-2 cursor-pointer transition-all group flex flex-col overflow-hidden ${displayFrameIndex === index ? 'border-purple-500 ring-2 ring-purple-500/20 bg-gray-700' : 'border-gray-600 bg-gray-750 hover:border-gray-500'}`}
                                        >
                                            <div className="flex-1 relative bg-gray-900 m-1 rounded border border-gray-800 overflow-hidden pointer-events-none">
                                                {performers.map(p => {
                                                    const pos = frame.positions[p.id];
                                                    if (!pos) return null;
                                                    const sizePctW = (performerSize / stageSize.width) * 100;
                                                    const sizePctH = (performerSize / stageSize.height) * 100;
                                                    
                                                    return (
                                                        <div 
                                                            key={p.id}
                                                            className="absolute"
                                                            style={{
                                                                left: `${(pos.x / stageSize.width) * 100}%`,
                                                                top: `${(pos.y / stageSize.height) * 100}%`,
                                                                width: `${sizePctW}%`,
                                                                height: `${sizePctH}%`,
                                                                transform: `translate(-50%, -50%)`
                                                            }}
                                                        >
                                                            <PerformerShape shape={p.shape} color={p.color} size="100%" />
                                                        </div>
                                                    )
                                                })}
                                            </div>

                                            <div className="h-5 sm:h-6 bg-gray-800 flex items-center justify-between px-1 sm:px-2">
                                                <span className="text-[9px] sm:text-[10px] text-gray-300 truncate w-12 sm:w-16">{frame.name}</span>
                                                <span className="text-[8px] sm:text-[9px] text-gray-500">{frame.duration/1000}s</span>
                                            </div>

                                            <button 
                                                onClick={(e) => { e.stopPropagation(); deleteFrame(index); }}
                                                disabled={isPlaying}
                                                className="absolute top-1 right-1 p-1 bg-red-500/80 hover:bg-red-600 text-white rounded opacity-100 sm:opacity-0 group-hover:opacity-100 transition disabled:hidden" 
                                            >
                                                <Trash2 size={10} />
                                            </button>

                                            <div className="absolute top-1 left-1 w-3 h-3 sm:w-4 sm:h-4 bg-gray-600/80 rounded flex items-center justify-center text-[8px] sm:text-[9px] text-white">
                                                {index + 1}
                                            </div>
                                        </div>
                                    ))}
                                    
                                    <button onClick={addFrame} disabled={isPlaying} className="flex-shrink-0 w-10 h-20 sm:w-12 sm:h-24 rounded-lg border-2 border-dashed border-gray-600 hover:border-gray-400 hover:bg-gray-800 flex items-center justify-center text-gray-500 transition disabled:opacity-30 disabled:cursor-not-allowed">
                                        <Plus size={24} />
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
